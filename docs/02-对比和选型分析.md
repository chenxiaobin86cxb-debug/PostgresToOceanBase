# PostgreSQL 与 OceanBase 对比选型分析

## 一、架构对比

### 1.1 架构设计差异

| 特性 | PostgreSQL | OceanBase |
|------|-----------|-----------|
| **架构类型** | 单机集群架构（主从） | 原生分布式架构 |
| **节点设计** | 中心化架构（Master-Slave） | 去中心化架构（无中心对等节点） |
| **存储方式** | 行存储，依赖本地存储 | 混合存储引擎（Delta + LSM-Tree） |
| **扩展性** | 垂直扩展为主，支持水平分片 | 水平扩展，支持在线扩容 |
| **一致性** | 主从复制，最终一致性 | Paxos 多副本强一致性 |
| **高可用** | 主从切换，需手动干预 | 自动故障转移，RPO=0, RTO<30s |
| **部署形态** | 单实例、主从、流复制 | Shared-Nothing / Shared-Storage 双架构 |

### 1.2 组件架构对比

#### PostgreSQL 架构
```
客户端
  ↓
PostgreSQL Server (单进程)
  ├── SQL 解析器
  ├── 查询优化器
  ├── 执行器
  └── 存储引擎
       ├── Heap Table
       ├── B-Tree / GiST / GIN 索引
       └── WAL (Write-Ahead Log)
  ↓
本地存储
```

**特点**：
- 单进程架构，通过多进程实现并发
- 插件化设计，支持丰富的扩展
- 适合单机或简单主从架构

#### OceanBase 架构
```
客户端
  ↓
OBProxy (接入层)
  ├── 协议兼容（MySQL/Oracle）
  ├── 读写分离
  ├── 路由转发
  └── 故障转移
  ↓
OBServer (SQL 层 + 存储层 + 事务层)
  ├── SQL 引擎
  │   ├── 双语法解析（MySQL/Oracle）
  │   ├── 并行执行
  │   └── 向量化执行
  ├── 事务引擎
  │   ├── 分布式事务（2PC）
  │   └── 快照隔离
  └── 存储引擎
       ├── Delta + LSM-Tree
       ├── 行存 + 列存（HTAP）
       └── Paxos 副本同步
  ↓
RootService (集群管控，可选)
```

**特点**：
- 多租户架构，资源隔离
- 支持 Shared-Nothing 和 Shared-Storage 双架构
- 原生 HTAP 混合负载能力

### 1.3 容灾能力对比

| 容灾级别 | PostgreSQL | OceanBase |
|---------|-----------|-----------|
| **机房级容灾** | 主从异步复制（数据可能丢失） | 多机房 Paxos 同步（RPO=0） |
| **城市级容灾** | 需要手动配置复杂的主从链路 | 三地五中心原生支持 |
| **故障切换** | 需要人工干预或自动化脚本 | 自动故障转移，RTO<30秒 |
| **数据恢复** | 基于 WAL 日志恢复 | 基于 Paxos 多副本自动恢复 |

### 1.4 扩展性对比

#### PostgreSQL 扩展方式
1. **垂直扩展**：增加单机 CPU、内存、存储
   - 优点：简单快速
   - 缺点：成本高，有上限

2. **水平扩展**：分库分表
   - 优点：理论上无限扩展
   - 缺点：需要应用层改造，跨分片查询复杂

#### OceanBase 扩展方式
1. **在线扩容**：增加节点自动重平衡
   - 优点：无需停机，自动迁移数据
   - 缺点：需要足够的节点数（至少3个）

2. **存储与计算分离**（V4.4+）
   - 优点：计算和存储独立扩展，成本优化
   - 缺点：需要共享存储支持

---

## 二、SQL 功能对比

### 2.1 DDL 语法差异

#### 表创建语法

**PostgreSQL**：
```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    tags TEXT[]
);
```

**OceanBase Oracle 租户**：
```sql
CREATE TABLE users (
    id NUMBER(10,0) PRIMARY KEY,
    name VARCHAR2(100) NOT NULL,
    email VARCHAR2(255) UNIQUE,
    created_at TIMESTAMP DEFAULT SYSTIMESTAMP
);

-- 序列（替代 SERIAL）
CREATE SEQUENCE seq_users_id;
```

**OceanBase MySQL 租户**：
```sql
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

#### 约束差异

| 约束类型 | PostgreSQL | OceanBase Oracle | OceanBase MySQL |
|---------|-----------|-----------------|----------------|
| 主键 | 支持 | 支持 | 支持 |
| 外键 | 支持 | 支持 | 支持 |
| 检查约束 | 支持 | 支持 | 支持 |
| 唯一约束 | 支持 | 支持 | 支持 |
| 唯一约束 NULL 值 | 多个 NULL 允许 | 仅第一个 NULL | 多个 NULL 允许 |
| 排他约束 | 支持 | 不支持 | 不支持 |

### 2.2 DML 语法差异

#### INSERT 语法

**PostgreSQL**（支持批量插入）：
```sql
INSERT INTO users (name, email, created_at) VALUES
    ('Alice', 'alice@example.com', '2024-01-01'),
    ('Bob', 'bob@example.com', '2024-01-02'),
    ('Charlie', 'charlie@example.com', '2024-01-03');
```

**OceanBase Oracle**：
```sql
INSERT ALL
    INTO users (id, name, email, created_at) 
    VALUES (seq_users_id.NEXTVAL, 'Alice', 'alice@example.com', TO_TIMESTAMP('2024-01-01', 'YYYY-MM-DD'))
    INTO users (id, name, email, created_at) 
    VALUES (seq_users_id.NEXTVAL, 'Bob', 'bob@example.com', TO_TIMESTAMP('2024-01-02', 'YYYY-MM-DD'))
    INTO users (id, name, email, created_at) 
    VALUES (seq_users_id.NEXTVAL, 'Charlie', 'charlie@example.com', TO_TIMESTAMP('2024-01-03', 'YYYY-MM-DD'))
SELECT * FROM DUAL;
```

**OceanBase MySQL**：
```sql
INSERT INTO users (name, email, created_at) VALUES
    ('Alice', 'alice@example.com', '2024-01-01'),
    ('Bob', 'bob@example.com', '2024-01-02'),
    ('Charlie', 'charlie@example.com', '2024-01-03');
```

#### UPDATE 语法（JOIN 更新）

**PostgreSQL**：
```sql
UPDATE users u
SET name = o.name
FROM orders o
WHERE u.id = o.user_id AND o.status = 'completed';
```

**OceanBase Oracle**：
```sql
UPDATE (SELECT u.name as old_name, o.name as new_name
        FROM users u, orders o
        WHERE u.id = o.user_id AND o.status = 'completed')
SET old_name = new_name;
```

**OceanBase MySQL**：
```sql
UPDATE users u
INNER JOIN orders o ON u.id = o.user_id
SET u.name = o.name
WHERE o.status = 'completed';
```

#### DELETE 语法（使用子查询）

**PostgreSQL**：
```sql
DELETE FROM users
WHERE id IN (SELECT user_id FROM orders WHERE status = 'cancelled');
```

**OceanBase Oracle**：
```sql
DELETE FROM users u
WHERE EXISTS (
    SELECT 1 FROM orders o
    WHERE o.user_id = u.id AND o.status = 'cancelled'
);
```

**OceanBase MySQL**：
```sql
DELETE users FROM users
INNER JOIN orders ON users.id = orders.user_id
WHERE orders.status = 'cancelled';
```

### 2.3 查询语法差异

#### 窗口函数

**PostgreSQL** 和 **OceanBase** 都支持标准窗口函数，但部分高级功能存在差异：

**PostgreSQL**：
```sql
SELECT 
    id,
    name,
    salary,
    ROW_NUMBER() OVER (PARTITION BY dept_id ORDER BY salary DESC) as rank,
    SUM(salary) OVER (PARTITION BY dept_id) as dept_total
FROM employees;
```

**OceanBase**：
```sql
-- Oracle 租户：支持更多窗口函数
SELECT 
    id,
    name,
    salary,
    ROW_NUMBER() OVER (PARTITION BY dept_id ORDER BY salary DESC) as rank,
    SUM(salary) OVER (PARTITION BY dept_id) as dept_total,
    RATIO_TO_REPORT(salary) OVER (PARTITION BY dept_id) as salary_ratio
FROM employees;
```

#### 分页查询

**PostgreSQL**：
```sql
SELECT * FROM users
ORDER BY id
LIMIT 10 OFFSET 20;
```

**OceanBase Oracle**：
```sql
SELECT * FROM (
    SELECT a.*, ROWNUM as rn
    FROM (SELECT * FROM users ORDER BY id) a
    WHERE ROWNUM <= 30
) WHERE rn > 20;
```

**OceanBase MySQL**：
```sql
SELECT * FROM users
ORDER BY id
LIMIT 10 OFFSET 20;
```

---

## 三、函数对比

### 3.1 字符串函数

| 函数功能 | PostgreSQL | OceanBase Oracle | OceanBase MySQL |
|---------|-----------|-----------------|----------------|
| 大小写转换 | UPPER/LOWER | UPPER/LOWER | UPPER/LOWER |
| 字符串拼接 | \|\| | \|\| | CONCAT() |
| 子串提取 | SUBSTRING() | SUBSTR() | SUBSTRING() |
| 字符串长度 | LENGTH() | LENGTH() | CHAR_LENGTH() |
| 字符串替换 | REPLACE() | REPLACE() | REPLACE() |
| 去除空格 | TRIM() | TRIM() | TRIM() |
| 字符串分割 | STRING_TO_ARRAY() | 自定义函数 | SUBSTRING_INDEX() |
| 字符串聚合 | STRING_AGG() | LISTAGG() | GROUP_CONCAT() |

### 3.2 日期时间函数

| 函数功能 | PostgreSQL | OceanBase Oracle | OceanBase MySQL |
|---------|-----------|-----------------|----------------|
| 当前时间 | CURRENT_TIMESTAMP | SYSTIMESTAMP | CURRENT_TIMESTAMP |
| 日期加减 | INTERVAL | INTERVAL | DATE_ADD() / DATE_SUB() |
| 日期差 | AGE() | MONTHS_BETWEEN() | DATEDIFF() |
| 日期格式化 | TO_CHAR() | TO_CHAR() | DATE_FORMAT() |
| 日期解析 | TO_DATE() | TO_DATE() | STR_TO_DATE() |
| 时间戳提取 | EXTRACT() | EXTRACT() | EXTRACT() |
| 时间戳转换 | TO_TIMESTAMP() | TO_TIMESTAMP() | FROM_UNIXTIME() |

#### 日期函数示例

**PostgreSQL**：
```sql
-- 当前时间
SELECT CURRENT_TIMESTAMP;

-- 日期加减
SELECT NOW() + INTERVAL '1 day';
SELECT NOW() - INTERVAL '1 month';

-- 日期差
SELECT AGE(NOW(), '2024-01-01'::DATE);

-- 日期格式化
SELECT TO_CHAR(NOW(), 'YYYY-MM-DD HH24:MI:SS');

-- 日期解析
SELECT TO_DATE('2024-01-01', 'YYYY-MM-DD');
```

**OceanBase Oracle**：
```sql
-- 当前时间
SELECT SYSTIMESTAMP FROM DUAL;

-- 日期加减
SELECT SYSTIMESTAMP + INTERVAL '1' DAY FROM DUAL;
SELECT ADD_MONTHS(SYSTIMESTAMP, -1) FROM DUAL;

-- 日期差
SELECT MONTHS_BETWEEN(SYSTIMESTAMP, TO_DATE('2024-01-01', 'YYYY-MM-DD')) FROM DUAL;

-- 日期格式化
SELECT TO_CHAR(SYSTIMESTAMP, 'YYYY-MM-DD HH24:MI:SS') FROM DUAL;

-- 日期解析
SELECT TO_DATE('2024-01-01', 'YYYY-MM-DD') FROM DUAL;
```

### 3.3 数值函数

| 函数功能 | PostgreSQL | OceanBase Oracle | OceanBase MySQL |
|---------|-----------|-----------------|----------------|
| 四舍五入 | ROUND() | ROUND() | ROUND() |
| 向上取整 | CEIL() | CEIL() | CEIL() |
| 向下取整 | FLOOR() | FLOOR() | FLOOR() |
| 绝对值 | ABS() | ABS() | ABS() |
| 平方根 | SQRT() | SQRT() | SQRT() |
| 幂运算 | POWER() | POWER() | POW() |
| 随机数 | RANDOM() | DBMS_RANDOM.VALUE() | RAND() |
| 取模 | MOD() | MOD() | MOD() |

### 3.4 聚合函数

| 函数功能 | PostgreSQL | OceanBase Oracle | OceanBase MySQL |
|---------|-----------|-----------------|----------------|
| 计数 | COUNT() | COUNT() | COUNT() |
| 求和 | SUM() | SUM() | SUM() |
| 平均 | AVG() | AVG() | AVG() |
| 最大值 | MAX() | MAX() | MAX() |
| 最小值 | MIN() | MIN() | MIN() |
| 字符串聚合 | STRING_AGG() | LISTAGG() | GROUP_CONCAT() |
| 去重聚合 | ARRAY_AGG() | COLLECT() | GROUP_CONCAT(DISTINCT) |
| 统计模式 | MODE() | STAT_MODE() | 无 |

### 3.5 JSON 函数差异（重点）

#### PostgreSQL JSON 函数（丰富）

**PostgreSQL** 支持原生 JSON 和 JSONB 类型，提供丰富的 JSON 操作函数：

```sql
-- 创建 JSON
SELECT '{"name": "Alice", "age": 30}'::JSON;
SELECT '{"name": "Alice", "age": 30}'::JSONB;

-- JSON 查询
SELECT data->'name' FROM users WHERE id = 1;  -- JSON
SELECT data->>'name' FROM users WHERE id = 1; -- JSONB

-- JSON 数组操作
SELECT array_to_json(ARRAY[1, 2, 3]);
SELECT json_array_length('[1, 2, 3]'::JSON);

-- JSON 对象操作
SELECT json_object_keys('{"a": 1, "b": 2}'::JSON);
SELECT json_each('{"a": 1, "b": 2}'::JSON);

-- JSON 路径查询
SELECT json_extract_path(data, 'name', 'first') FROM users;

-- JSONB 高级操作
SELECT jsonb_insert(data, '{new_key}', 'new_value') FROM users;
SELECT jsonb_set(data, '{age}', '31') FROM users;
```

#### OceanBase JSON 函数（有限）

**OceanBase Oracle 租户**：
```sql
-- JSON 数据存储为 CLOB
-- 需要应用层解析或使用 PL/JSON 扩展

-- 示例：创建 JSON 对象
SELECT JSON_OBJECT('name' VALUE 'Alice', 'age' VALUE 30) FROM DUAL;

-- JSON 查询（使用 JSON_TABLE）
SELECT t.*
FROM users u,
     JSON_TABLE(
         u.json_data,
         '$' COLUMNS (
             name VARCHAR2(100) PATH '$.name',
             age NUMBER PATH '$.age'
         )
     ) t;
```

**OceanBase MySQL 租户**：
```sql
-- JSON 数据类型支持
CREATE TABLE users (
    id INT,
    data JSON
);

-- JSON 查询
SELECT data->'$.name' FROM users WHERE id = 1;
SELECT JSON_EXTRACT(data, '$.age') FROM users WHERE id = 1;

-- JSON 数组操作
SELECT JSON_ARRAY(1, 2, 3);
SELECT JSON_LENGTH('[1, 2, 3]');

-- JSON 对象操作
SELECT JSON_KEYS('{"a": 1, "b": 2}');

-- JSON 路径查询
SELECT JSON_EXTRACT(data, '$.name') FROM users;
```

**迁移建议**：
- **PostgreSQL JSON/JSONB → OceanBase CLOB**：将 JSON 类型转换为 CLOB 存储，应用层使用 JSON 库解析
- **使用 JSON 函数的查询**：需要改写 SQL，在应用层处理 JSON 数据
- **复杂 JSON 操作**：考虑在应用层实现，避免在数据库中处理

### 3.6 数组函数差异（重点）

#### PostgreSQL 数组函数

**PostgreSQL** 支持原生数组类型：

```sql
-- 创建数组
CREATE TABLE users (
    id INT,
    tags TEXT[]
);

-- 插入数组数据
INSERT INTO users (id, tags) VALUES (1, ARRAY['tag1', 'tag2', 'tag3']);

-- 数组查询
SELECT tags FROM users WHERE id = 1;
SELECT tags[1] FROM users WHERE id = 1;  -- 索引从 1 开始

-- 数组操作
SELECT array_length(tags, 1) FROM users WHERE id = 1;  -- 数组长度
SELECT array_position(tags, 'tag2') FROM users WHERE id = 1;  -- 元素位置
SELECT array_to_string(tags, ',') FROM users WHERE id = 1;  -- 数组转字符串
SELECT string_to_array('tag1,tag2,tag3', ',');  -- 字符串转数组

-- 数组包含查询
SELECT * FROM users WHERE 'tag1' = ANY(tags);
SELECT * FROM users WHERE tags @> ARRAY['tag1', 'tag2'];  -- 包含关系
```

#### OceanBase 数组处理

**OceanBase Oracle 租户**：不支持原生数组类型

```sql
-- 方案1：使用 CLOB 存储逗号分隔的字符串
CREATE TABLE users (
    id NUMBER(10,0),
    tags VARCHAR2(4000)
);

-- 插入数据
INSERT INTO users (id, tags) VALUES (1, 'tag1,tag2,tag3');

-- 查询（使用字符串函数）
SELECT tags FROM users WHERE id = 1;
-- 检查是否包含某个标签（需要使用 REGEXP_LIKE）
SELECT * FROM users WHERE REGEXP_LIKE(tags, '(^|,)tag2(,|$)');
```

**OceanBase MySQL 租户**：不支持原生数组类型

```sql
-- 方案1：使用 JSON 类型（推荐）
CREATE TABLE users (
    id INT,
    tags JSON
);

-- 插入数据
INSERT INTO users (id, tags) VALUES (1, '["tag1", "tag2", "tag3"]');

-- 查询
SELECT tags FROM users WHERE id = 1;
SELECT JSON_EXTRACT(tags, '$[0]') FROM users WHERE id = 1;

-- 方案2：使用关联表（关系型设计）
CREATE TABLE users (
    id INT,
    name VARCHAR(100)
);

CREATE TABLE user_tags (
    user_id INT,
    tag VARCHAR(100),
    PRIMARY KEY (user_id, tag)
);

-- 查询用户的标签
SELECT t.tag 
FROM users u
JOIN user_tags t ON u.id = t.user_id
WHERE u.id = 1;

-- 检查用户是否包含某个标签
SELECT u.* FROM users u
WHERE u.id IN (
    SELECT user_id FROM user_tags WHERE tag = 'tag2'
);
```

**迁移建议**：
1. **简单数组**：转换为逗号分隔的字符串
2. **复杂数组**：拆分为关联表
3. **频繁查询的数组**：使用 OceanBase MySQL 租户的 JSON 类型
4. **避免使用数组包含查询**：改为 JOIN 查询

### 3.7 序列函数差异

#### PostgreSQL 序列

```sql
-- 创建序列
CREATE SEQUENCE seq_users_id
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;

-- 使用序列
SELECT nextval('seq_users_id');  -- 获取下一个值
SELECT currval('seq_users_id');  -- 获取当前值
SELECT setval('seq_users_id', 100);  -- 设置当前值

-- 自动序列（SERIAL/BIGSERIAL）
CREATE TABLE users (
    id SERIAL PRIMARY KEY,  -- 等价于 INT + DEFAULT nextval()
    name VARCHAR(100)
);
```

#### OceanBase Oracle 序列

```sql
-- 创建序列
CREATE SEQUENCE seq_users_id
    START WITH 1
    INCREMENT BY 1
    NOCACHE;

-- 使用序列
SELECT seq_users_id.NEXTVAL FROM DUAL;
SELECT seq_users_id.CURRVAL FROM DUAL;
```

#### OceanBase MySQL 自增列

```sql
-- 自增列
CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100)
);

-- 获取最后插入的 ID
SELECT LAST_INSERT_ID();
```

---

## 四、数据类型详细映射

### 4.1 数值类型

| PostgreSQL | OceanBase Oracle | OceanBase MySQL | 注意事项 |
|-----------|-----------------|----------------|----------|
| SMALLINT (2字节) | NUMBER(5,0) | SMALLINT | 范围：-32768 ~ 32767 |
| INTEGER (4字节) | NUMBER(10,0) | INT | 范围：-2^31 ~ 2^31-1 |
| BIGINT (8字节) | NUMBER(19,0) | BIGINT | 范围：-2^63 ~ 2^63-1 |
| DECIMAL(p,s) | NUMBER(p,s) | DECIMAL(p,s) | 精度必须保持一致 |
| NUMERIC(p,s) | NUMBER(p,s) | DECIMAL(p,s) | 同 DECIMAL |
| REAL (4字节) | BINARY_FLOAT | FLOAT | 单精度浮点，7位有效数字 |
| DOUBLE PRECISION | BINARY_DOUBLE | DOUBLE | 双精度浮点，15位有效数字 |
| SERIAL | 使用序列 | AUTO_INCREMENT | PostgreSQL 特有 |
| BIGSERIAL | 使用序列 | BIGINT AUTO_INCREMENT | PostgreSQL 特有 |
| MONEY | NUMBER(19,4) | DECIMAL(19,4) | 货币类型 |

**数值精度示例**：
```sql
-- PostgreSQL
CREATE TABLE products (
    price DECIMAL(10, 2)  -- 总共10位，小数点后2位
);

-- OceanBase Oracle
CREATE TABLE products (
    price NUMBER(10, 2)
);

-- OceanBase MySQL
CREATE TABLE products (
    price DECIMAL(10, 2)
);
```

### 4.2 字符串类型

| PostgreSQL | OceanBase Oracle | OceanBase MySQL | 注意事项 |
|-----------|-----------------|----------------|----------|
| CHAR(n) | CHAR(n) | CHAR(n) | 定长字符串，不足补空格 |
| VARCHAR(n) | VARCHAR2(n) | VARCHAR(n) | 变长字符串 |
| TEXT | CLOB | TEXT | 长文本数据 |
| BYTEA | BLOB | VARBINARY/BLOB | 二进制数据 |
| NAME | VARCHAR2(128) | VARCHAR(128) | 内部标识符类型 |

**字符串长度说明**：
- **PostgreSQL**：VARCHAR(n) 的 n 表示字符数
- **OceanBase Oracle**：VARCHAR2(n) 的 n 表示字节数
- **OceanBase MySQL**：VARCHAR(n) 的 n 表示字符数（UTF-8）

**迁移注意事项**：
```sql
-- PostgreSQL
CREATE TABLE users (
    email VARCHAR(255)  -- 最多 255 个字符
);

-- OceanBase Oracle（需要考虑 UTF-8 编码）
CREATE TABLE users (
    email VARCHAR2(765)  -- 255 * 3 (每个 UTF-8 字符最多 3 字节)
);

-- OceanBase MySQL
CREATE TABLE users (
    email VARCHAR(255)  -- 最多 255 个字符
);
```

### 4.3 日期时间类型

| PostgreSQL | OceanBase Oracle | OceanBase MySQL | 注意事项 |
|-----------|-----------------|----------------|----------|
| DATE | DATE | DATE | 日期（年月日） |
| TIME | 不支持 | TIME | 时间（时分秒） |
| TIME WITH TIME ZONE | TIMESTAMP WITH TIME ZONE | 不支持 | 带时区的时间 |
| TIMESTAMP | TIMESTAMP | TIMESTAMP | 日期时间 |
| TIMESTAMP WITH TIME ZONE | TIMESTAMP WITH TIME ZONE | TIMESTAMP | 带时区的日期时间 |
| INTERVAL | INTERVAL | 不支持 | 时间间隔 |

**日期时间示例**：
```sql
-- PostgreSQL
CREATE TABLE events (
    id INT,
    event_time TIMESTAMP WITH TIME ZONE,
    duration INTERVAL
);

-- OceanBase Oracle
CREATE TABLE events (
    id NUMBER(10,0),
    event_time TIMESTAMP WITH TIME ZONE,
    duration INTERVAL DAY TO SECOND
);

-- OceanBase MySQL
CREATE TABLE events (
    id INT,
    event_time TIMESTAMP,
    duration INT  -- 使用秒存储时间间隔
);
```

### 4.4 布尔类型

| PostgreSQL | OceanBase Oracle | OceanBase MySQL | 注意事项 |
|-----------|-----------------|----------------|----------|
| BOOLEAN | NUMBER(1,0) | TINYINT(1) | 0=FALSE, 1=TRUE |

**布尔类型示例**：
```sql
-- PostgreSQL
CREATE TABLE users (
    id INT,
    is_active BOOLEAN DEFAULT TRUE
);

-- OceanBase Oracle
CREATE TABLE users (
    id NUMBER(10,0),
    is_active NUMBER(1,0) DEFAULT 1  -- 0=FALSE, 1=TRUE
);

-- OceanBase MySQL
CREATE TABLE users (
    id INT,
    is_active TINYINT(1) DEFAULT 1
);
```

### 4.5 特殊类型

| PostgreSQL | OceanBase Oracle | OceanBase MySQL | 迁移方案 |
|-----------|-----------------|----------------|----------|
| JSON | CLOB | JSON | 应用层处理 |
| JSONB | CLOB | JSON | 应用层处理 |
| ARRAY | CLOB | JSON | 拆分表或 JSON |
| UUID | VARCHAR2(36) | VARCHAR(36) | 字符串存储 |
| ENUM | VARCHAR2(n) | ENUM | 字符串或 ENUM |
| GEOMETRY | 不支持 | 不支持 | 应用层处理 |
| XML | CLOB | 不支持 | CLOB 存储 |

---

## 五、运维特性对比

### 5.1 备份恢复

| 特性 | PostgreSQL | OceanBase |
|------|-----------|-----------|
| **备份方式** | pg_dump, WAL 归档 | 全量备份 + 增量备份 |
| **备份工具** | pg_dump, pg_basebackup | ob_backup, OMS |
| **恢复速度** | 较慢（需要重放 WAL） | 快（多副本并行恢复） |
| **时间点恢复** | 支持（PITR） | 支持 |
| **增量备份** | WAL 归档 | 原生支持 |
| **备份存储** | 本地或远程 | 本地或对象存储 |

**PostgreSQL 备份示例**：
```bash
# 全量备份
pg_dump -h localhost -U postgres -d mydb -f mydb_backup.sql

# 自定义格式备份
pg_dump -h localhost -U postgres -d mydb -F c -f mydb_backup.dump

# 基础备份（用于 PITR）
pg_basebackup -h localhost -D /var/lib/postgresql/backup -U postgres
```

**OceanBase 备份示例**：
```bash
# 使用 OMS 备份
obclient -h localhost -P 2881 -u admin@sys -p -e "ALTER SYSTEM SET backup_dest='file:///backup'"

# 全量备份
ob_admin backup_tenant -t sys -c full

# 增量备份
ob_admin backup_tenant -t sys -c incremental
```

### 5.2 监控指标

| 监控项 | PostgreSQL | OceanBase |
|-------|-----------|-----------|
| **连接数** | pg_stat_activity | GV$SESSION |
| **查询统计** | pg_stat_statements | GV$SQL |
| **锁等待** | pg_locks | GV$LOCK |
| **复制延迟** | pg_stat_replication | GV$OB_LOGSTAT |
| **表大小** | pg_class | GV$OB_TABLET_TO_TABLE |
| **索引使用** | pg_stat_user_indexes | GV$OB_INDEX_STATISTICS |

### 5.3 高可用配置

#### PostgreSQL 高可用
```bash
# 主库配置
postgresql.conf:
wal_level = replica
max_wal_senders = 10
wal_keep_segments = 100

pg_hba.conf:
host    replication     repl_user     0.0.0.0/0     md5

# 从库配置
recovery.conf:
standby_mode = 'on'
primary_conninfo = 'host=primary port=5432 user=repl_user'
```

#### OceanBase 高可用
```sql
-- 创建 3 副本集群
ALTER SYSTEM SET default_replica_num = 3;

-- 设置 Primary Zone
ALTER SYSTEM SET primary_zone = 'zone1,zone2,zone3';

-- 故障恢复配置
ALTER SYSTEM SET auto_leader_switch_interval = '10s';
```

---

## 六、成本和迁移风险评估

### 6.1 成本对比

| 成本项 | PostgreSQL | OceanBase |
|-------|-----------|-----------|
| **软件许可** | 开源免费 | 开源免费 / 企业版收费 |
| **硬件成本** | 中等（单机或主从） | 较高（至少3节点） |
| **运维成本** | 中等 | 较高（分布式运维复杂） |
| **人力成本** | 低（生态成熟） | 较高（需要学习） |
| **迁移成本** | 无 | 中高（需要改造） |
| **长期成本** | 中等 | 低（可线性扩展） |

### 6.2 迁移工作量评估

| 数据规模 | PostgreSQL | OceanBase | 迁移工作量 |
|---------|-----------|-----------|-----------|
| < 10GB | 单机 | 3节点 | 高（硬件成本高） |
| 10GB - 100GB | 主从 | 3节点 | 中高 |
| 100GB - 1TB | 分库分表 | 3-9节点 | 中 |
| > 1TB | 复杂分库分表 | 9+节点 | 低 |

**迁移工作量估算**：
- **简单迁移**（数据类型兼容）：1-2周
- **中等复杂度**（需要改写 SQL）：1-2个月
- **复杂迁移**（重构应用）：3-6个月

### 6.3 风险评估

| 风险类型 | 风险等级 | 影响范围 | 应对措施 |
|---------|---------|---------|---------|
| **数据丢失** | 高 | 全部数据 | 完整测试、备份、监控 |
| **应用改造** | 中 | 应用层 | 渐进式迁移、双写 |
| **性能下降** | 中 | 用户体验 | 性能测试、优化参数 |
| **功能缺失** | 中 | 特定功能 | 替代方案、应用层实现 |
| **运维复杂** | 低 | 运维团队 | 培训、文档、自动化工具 |
| **成本超支** | 中 | 预算 | 详细评估、分阶段实施 |

### 6.4 关键决策因素

#### 选择迁移到 OceanBase 的情况：

1. **数据量增长快**：超过单机承载能力，需要分布式扩展
2. **高可用要求高**：需要 RPO=0、RTO<30秒的容灾能力
3. **成本敏感**：长期使用成本更低（避免 Oracle 高额许可）
4. **国产化要求**：信创、自主可控需求
5. **HTAP 需求**：需要同时支持 OLTP 和 OLAP 负载

#### 继续使用 PostgreSQL 的情况：

1. **数据量小**：< 100GB，单机或主从足够
2. **应用复杂**：大量使用 PostgreSQL 独有功能（JSONB、数组、复杂查询）
3. **团队熟悉**：运维和开发团队熟悉 PostgreSQL
4. **时间紧迫**：无法投入足够时间进行迁移改造
5. **成本敏感**：无法承担 OceanBase 初始硬件投入

---

## 七、兼容性检查清单

### 7.1 数据类型兼容性检查

- [ ] 检查是否使用 JSON/JSONB 类型
- [ ] 检查是否使用 ARRAY 类型
- [ ] 检查是否使用 ENUM 类型
- [ ] 检查是否使用 UUID 类型
- [ ] 检查是否使用 GEOMETRY 类型
- [ ] 检查数值类型精度是否兼容
- [ ] 检查字符串类型长度是否需要调整

### 7.2 SQL 功能兼容性检查

- [ ] 检查是否使用 PostgreSQL 独有函数
  - [ ] JSON 函数
  - [ ] 数组函数
  - [ ] 字符串函数（STRING_TO_ARRAY、STRING_AGG）
  - [ ] 日期函数（AGE、DATE_TRUNC）
- [ ] 检查是否使用窗口函数
- [ ] 检查是否使用 CTE（WITH 子句）
- [ ] 检查是否使用 FULL OUTER JOIN
- [ ] 检查是否使用 UNION 中的 ORDER BY

### 7.3 应用层改造检查

- [ ] 检查是否使用原生 PostgreSQL 驱动
- [ ] 检查是否使用 ORM（Hibernate、MyBatis 等）
- [ ] 检查是否使用数据库特有功能（如 LISTEN/NOTIFY）
- [ ] 检查事务隔离级别是否兼容
- [ ] 检查批量插入语法是否需要修改

### 7.4 性能影响评估

- [ ] 评估查询性能变化
- [ ] 评估写入性能变化
- [ ] 评估索引使用情况
- [ ] 评估存储空间需求（1.5-2倍）
- [ ] 评估网络带宽需求

### 7.5 数据迁移验证

- [ ] 记录数对比
- [ ] 抽样数据对比
- [ ] 汇总值对比（SUM、AVG、MAX、MIN）
- [ ] 业务功能验证
- [ ] 性能测试

---

## 八、迁移决策树

```
开始
  ↓
数据量 < 100GB?
  ├─ 是 → 继续使用 PostgreSQL（成本低）
  └─ 否 → ↓
  ↓
高可用要求（RPO=0）?
  ├─ 否 → PostgreSQL 主从 + 监控
  └─ 是 → ↓
  ↓
预算充足（> 3 节点硬件）?
  ├─ 否 → PostgreSQL 分库分表
  └─ 是 → ↓
  ↓
应用是否大量使用 PostgreSQL 独有功能？
  ├─ 是 → 评估改造成本
  │     ├─ 成本可接受 → OceanBase
  │     └─ 成本不可接受 → PostgreSQL
  └─ 否 → OceanBase
```

---

## 九、参考资源

### 官方文档
- [PostgreSQL 文档](https://www.postgresql.org/docs/)
- [OceanBase 官方文档](https://www.oceanbase.com/docs)
- [OceanBase 开源社区](https://github.com/oceanbase/oceanbase)

### 迁移工具
- [阿里云数据传输服务](https://www.aliyun.com/product/dts)
- [OMS 数据迁移工具](https://www.oceanbase.com/product/oms)

### 学习资源
- [PostgreSQL 中文社区](https://www.postgres.cn/)
- [OceanBase 开发者社区](https://developer.aliyun.com/group/oceanbase)
- [墨天轮数据库社区](https://www.modb.pro/)

---

**文档版本**：v1.0  
**更新日期**：2025-01-12  
**适用范围**：PostgreSQL → OceanBase 迁移决策和兼容性评估
